					Testing theory

## Quality assurance, Quality control и Testing. Who is who?

1. **Testing** - самый первый уровень. Это проверка программного продукта на соответствие требованиям этого продукта. То есть когда ожидаемый и фактический результат совпадают, и это тот минимум, без которого нельзя выпускать продукт.
2**2. QC (Quality Control, контроль качества)** - второй уровень, включает в себя тестирование и контроль за соответствием заранее согласованному уровню качества и готовность к выпуску продукта в прод.
1. **QA (Quality Assurance, обеспечение качества)** - часть обеспечения согласованного уровня качества. Сюда может входить тестирование документации, ревью кода на соответствие стандартам, внедрение каких-то методик по работе с качеством. 
Для полного понимания обращаемся к [ГОСТ Р ИСО 9000-2015](https://sudact.ru/law/gost-r-iso-9000-2015-natsionalnyi-standart-rossiiskoi/gost-r-iso-9000-2015/%23:~:text=%D0%93%D0%9E%D0%A1%D0%A2%20%D0%A0%20%D0%98%D0%A1%D0%9E%209000-2015.%20%D0%9D%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9,%28IDT%29%20%D0%94%D0%B0%D1%82%D0%B0%20%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F%20-%202015-11-01)

**ПРИНЦИПЫ ТЕСТИРОВАНИЯ:**
  -Тестирование не может доказать отсутствие багов(только их наличие);
 - Исчерпывающее тестирование невозможно по определению;
 - Раннее тестирование позволяет сэкономить ресурсы;
 - Парадокс пестицидов;
 - Кластеризация багов;
 - Тестирование зависит от контекста;
 - Заблуждение об отсутствии багов;



## SDLC, Waterfall, Agile и CI/CD. Who is who?
 
**Жизненный цикл ПО (SLDC)** - это период времени, который начинается с возникновения идеи продукта до прекращения его использования - вывода из эксплуатации. 

Он состоит из последовательных этапов: 
-Анализ требований. На этом этапе составляется ТЗ(Техническое задание – это документ, содержащий информацию для постановки задач на разработку), обозначаются сроки по каждой задаче и план работ. Здесь также нужно учитывать все возможные риски. Как только все детали просчитаны и описаны  можно переходить к следующему этапу;
 - Дизайн системы. Разрабатывается прототип, дизайн-макет, платформа для программирования. Все члены команды должны быть расписаны по ролям, а также необходимо указать их обязанности;
 - Разработка. Команда пишет код продукта, согласно требованиям технического задания;
 - Тестирование. Проверка продукта, когда код написан. Если все благополучно, работу можно считать практически законченной;
 - Техническая поддержка. После релиза продукта, команда разработки поддерживает работу проекта на стабильном уровне, собирая обратную связь от пользователей и устраняя баги, если они возникают.


![image.png](5c0f61a0-839d-4b57-bcda-9ce4076d6a85.png)

Правильный порядок этапов жизненного цикла ПО:
Анализ требований
Проектирование
Разработка 
Тестирование
Техническая поддержка

**Waterfall** - водопадная/каскадная модель разработки, дублирует этапы жц ПО и позволяет решать задачи последовательно без возврата на пред. этапы

Принципы Waterfall:
 - Следуйте правилам;
 - Нет ТЗ — нет продукта; 
 - Чем подробнее ТЗ, тем лучше продукт; 
 - Следите, чтобы не было изменений

По мере развития и распространения ПО, нужно было максимально погружаться в проект, чтобы контролировать изменения, взаимодействовать с командой, предлагать новые решения. В рамках Waterfall это было невозможно, так как водопадная модель разработки не была гибкой. Именно в этот момент и появился Agile.

**Agile** - это группа методик для гибкого управления продуктом. Суть - проект разбивается на временные промежутки - спринты. Во время каждого спринта команда разработки создает часть продукта, которую можно потестить. Такой подход позволяет вносить правки на любом этапе. 
В Agile работа строится по логике:
 - составление ТЗ; 
 - проектирование; 
 - разработка; 
 - тестирование;
 - результат.

Манифест гибкой разработки ПО: 
 - Люди важнее инструментов. 
 - Качество продукта важнее документации. 
 - Взаимодействие с заказчиком важнее контракта. 
 - Готовность к изменениям важнее установленного плана.

В разработке любого софта есть два подхода: итеративный и непрерывный.

В итеративном пользователи видят продукт только в конце этапа, а до этого пользуются старой версией. 

Непрерывный позволяет каждый день получать новую версию, которую уже можно использовать. Он самый популярный (концепция CI/CD - Continuous Integration/Continuous Delivery - непрерывная интеграция и доставка). Это автоматизация тестирования и доставки новых модулей ПО пользователям. CI/CD относится к Agile-методологиям. 
CI/CD чаще всего зависит от тестировщиков и девопсов:
  - Тестировщики следят за тем, что новые изменения не повлияли на качество продукта; 
 - Девопсы автоматизируют процесс доставки ПО. 
  Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев при сборке ПО.

> **ISTQB - **Совет по сертификации тестирования программного обеспечения, действующий на международном уровне.

**Метод черного ящика (black box)**
Тестирование черного ящика ( отсутствие доступа к коду ) или тестирование поведения — техника, основанная на работе исключительно с внешними интерфейсами системы.

**Метод белого ящика (white box)**
 Тестирование белого ящика ( полный доступ к коду / сам писал код ) — метод тестирования ПО, который предполагает, что внутренняя структура/устройство/реализация системы известны тестировщику.
**Пример** : двигатель автомобиля. Для водителя (особенно начинающего) двигатель автомобиля - черный ящик. Но, для механика нет. Он, словно программист, понимает логику работы компонентов двигателя и знает его слабые места.

**Метод серого ящика (grey box)**
 Тестирование серого ящика ( частичный доступ к коду ) — метод тестирования ПО, который предполагает комбинацию White Box и Black Box подходов. То есть, внутреннее устройство программы нам известно лишь частично.
**Преимущества:**
  - Тестирование серого ящика включает в себя плюсы тестирования «черного» и «белого». Другими словами, тестировщик смотрит на объект тестирования с позиции «черного» ящика, но при этом проводит анализ на основе тех данных, что он знает о системе;
 - Тестировщик может проектировать и использовать более сложные сценарии тестирования;
 - Предоставляет разработчику достаточно времени для исправления дефектов.
  **Недостатки:**
  - Возможность анализа кода и тестового покрытия ограничена, так как доступ к исходному коду ограничен.
 - Тесты могут быть избыточными в том случае, когда разработчик также проверяет свой код Unit-тестами.
  **Пример:** разработчик, проверяющий программу, методом черного ящика ИЛИ тестировщик, ознакомившийся с архитектурой программы, проверяющий программу, методом черного ящика. Оба понимают логику работы программы, но проверяют ее, с точки зрения пользователя. 

**ISTQB ** относит тестирование методами белого и черного ящика к методам проектирования тестов. Поэтому, ни о каком «среднем» или «промежуточном» методе в этом случае конечно и речи быть не может. Мы либо разрабатываем тесты, зная код, либо не зная его. То есть в классификации  **ISTQB ** такого вида тестирования не существует.

Выделяют четыре уровня тестирования:
  - Модульное тестирование (Component/Unit testing);
 - Интеграционное тестирование (Integration testing);
 - Системное тестирование (System testing);
 - Приемочное тестирование (Acceptance testing).

  Задачи любого уровня тестирования:
  - Снижение риска;
 - Обнаружение дефектов;
 - Предотвращение перехода дефектов на более высокие уровни.

**Модульное тестирование**
 Для обозначения модульного тестирования используется множество синонимичных названий: модульное, юнит или компонентное.
 Модульное тестирование проводится, вызывая код. Производится, как правило, разработчиками. 

**Интеграционное тестирование**
Это тестирование взаимодействия модулей системы или нескольких систем.
Так как разные модули приложения могут разрабатываться разными программистами - необходимо проверить взаимодействие между ними.
Например, со страницы корзины при нажатии кнопки «Оплатить» происходит переход на страницу платежной системы и осуществляется оплата.
Типичные дефекты: 
-Отсутствие или неправильные данные;
-Сбои связи между компонентами;
-Нарушение обязательных правил безопасности. 

**Системное тестирование**
Производится после окончания интеграционного. Сначала разработчики создают и тестируют модули, затем интегрируют и тестируют модули между собой. В результате получается некая завершенная система, базовая модель приложения. Цель системного тестирования: проверить все приложение целиком.
 
На системном уровне тестирования проводится тестирование полного пути (end-to-end/E2E flow) использования продукта. Под путем использования понимается вся цепочка взаимодействия от запуска приложения до какого-то конечного результата.
 Пример сценария end-to-end для интернет магазина:
  - Незарегистрированный пользователь переходит на сайт интернет магазина;
 - Регистрируется на сайте;
 - Авторизуется на сайте;
 - Находит необходимый товар;
 - Добавляет его в корзину;
 - Статус заказа «Ожидает оплаты»;
 - Оплачивает заказ;
 - Деньги поступают на счет компании;
 - Статус заказа меняется на «Оплачен»;
 - После получения заказа пользователем статус заказа меняется на «Получен».
  Типичные дефекты:
  - Неожиданное или неверное поведение системы;
 - Система неспособна выполнять end-to-end задачи;
 - Система неспособна правильно работать в различных средах;
 - Система работает не в соответствии с пользовательским руководством.

Приемочное тестирование включает в себя формы:
-Пользовательское приемочное тестирование (User acceptance testing) - производится пользователями конечного продукта. 
-Операционные приемочные испытания (Operational acceptance testing) - проводят сис админы. Проверяется функции резервного копирования, установка/ удаление/ обновление системы, проверка безопасности и производительности приложения. Необходимо удостовериться, что приложение возможно обслуживать и сопровождать на требуемом уровне даже в экстремальных условиях
-Контрактные и нормативные приемочные испытания (Contractual and regulatory acceptance testing) - Проверка что приложение соблюдает все нормативные требования, продукт не нарушает чью-то интеллектуальную собственность или не использует нелицензионный софт. 
 -Альфа и бета-тестирование (Alpha and beta testing ).

*Альфа тестирование*  включает имитацию реального использования продукта штатными  или сторонними разработчиками, либо командой тестировщиков.
 *Бета-тестирование*  —  производится реальными пользователями, с целью получения от них обратной связи и выявления максимального числа ошибок для их последующего устранения перед окончательным выходом продукта на рынок (релизом).

Подходы к тестированию по степени формализации:
**Тестирование на основе тест-кейсов**: Тест-кейс — это совокупность входных данных, условий выполнения и ожидаемого результата, необходимых для проверки реализации функционала тестируемого программного обеспечения (ПО) или какого-то его свойства.

**Исследовательское тестирование**(Exploratory testing) - тест-кейсы не создаются заранее, а тестер проверяет на лету. 
Исследовательское тестирование ориентировано больше на тестирование как на мыслительную деятельность, а не как на бездумное воспроизведение по заранее написанному сценарию. При тестировании по сценарию ты сначала разрабатываешь тестовые случаи, а затем исполняешь их. Исследовательское тестирование — это одновременный процесс разработки и выполнения тестов. Вместо сценариев - чек-листы. 

**Свободное (интуитивное) тестирование**(Ad Hoc Testing или Monkey testing) - полностью формализованный подход, в котором не исп. ни тест-кейсы, ни сценарии, ни чек-листы. Полностью на интуиции и спонтанных действиях которые предположительно могут вызвать ошибку. Такое тестирование не требует никакой документации, планирования, наличия процессов, которых следует придерживаться при выполнении тестирования. 
Делится на 2 вида:
*buddy testing (совместное тестирование)* — когда 2 человека, как правило разработчик + тестировщик, работают параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает тестировщику выполнять необходимые проверки, а программисту фиксить баги на ранних этапах.

 *pair testing (парное тестирование)* —  когда 2 тестировщика проверяют один модуль и помогают друг другу. К примеру, один может искать дефекты, а второй —  их документировать.
